name: Build → Push → Deploy (CloudBolt) → Test → Teardown

on:
  workflow_dispatch:
  push:
    branches: [main]

jobs:
  build_deploy_test:
    runs-on: ubuntu-latest
    env:
      IMAGE_REPO: ghcr.io/${{ github.repository }}
      IMAGE_TAG: ${{ github.sha }}
      CB_INSECURE: ${{ vars.CB_INSECURE }} # set to "true" if self-signed certs


    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build Docker image
        run: docker build -t $IMAGE_REPO:$IMAGE_TAG .

      - name: Push Docker image
        run: docker push $IMAGE_REPO:$IMAGE_TAG

      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Compute curl SSL flag
        id: curl_flags
        run: |
          if [ "${CB_INSECURE:-false}" = "true" ]; then
            echo "flag=--insecure" >> $GITHUB_OUTPUT
          else
            echo "flag=" >> $GITHUB_OUTPUT
          fi

      - name: Get CloudBolt API token
        id: get_token
        run: |
          resp=$(curl -s ${{ steps.curl_flags.outputs.flag }} -X POST \
            "${{ secrets.CB_BASE_URL }}/api/v3/cmp/apiToken/" \
            -H "Accept: application/json" -H "Content-Type: application/json" \
            -d "{\"username\":\"${{ secrets.CB_USER }}\",\"password\":\"${{ secrets.CB_USER_PASSWORD }}\"}")
          echo "$resp"
          token=$(echo "$resp" | jq -r '.token')
          if [ -z "$token" ] || [ "$token" = "null" ]; then
            echo "Failed to obtain CloudBolt token" >&2
            exit 1
          fi
          echo "token=$token" >> $GITHUB_OUTPUT

      - name: Create CloudBolt order (deploy blueprint)
        id: create_order
        env:
          IMAGE_FULL: ${{ env.IMAGE_REPO }}:${{ env.IMAGE_TAG }}
        run: |
          # Normalize base URL (remove trailing slash)
          BASE="${{ secrets.CB_BASE_URL }}"
          BASE="${BASE%/}"

          DEPLOY_URL="$BASE/api/v3/cmp/blueprints/${{ secrets.CB_BLUEPRINT_ID_FLASK }}/deploy/"

          # Build payload with jq to avoid quoting issues
          PAYLOAD=$(jq -n \
            --arg img "$IMAGE_FULL" \
            '{
              deploymentItems: {
                "plugin-bdi-ipppr9ja": {parameters: {}},
                "script-bdi-in42nqrx": {parameters: {}},
                "script-bdi-k8y73pqh": {parameters: {image: $img}},
                "script-bdi-kapa01l8": {parameters: {}},
                "script-bdi-l5yxpsxd": {parameters: {}},
                "script-bdi-ti1aks7u": {parameters: {}},
                "server-bdi-8s22ypl4": {
                  environment: "/api/v3/cmp/environments/ENV-kh021i2j/",
                  osBuild: "/api/v3/cmp/osBuilds/OSB-qe8x525n/",
                  parameters: {
                    acme_billing_code: "1234",
                    expiration_date: "2025-08-08"
                  }
                }
              },
              group: "/api/v3/cmp/groups/GRP-6nsw3vt8/",
              parameters: {}
            }')

          # Use computed SSL flag; default to --insecure if unset
          CURL_FLAG='${{ steps.curl_flags.outputs.flag }}'
          if [ -z "$CURL_FLAG" ]; then CURL_FLAG="--insecure"; fi

          # Call deploy endpoint with Bearer token (matches your Postman call)
          http_code=$(curl -s -o /tmp/order_resp.json -w "%{http_code}" $CURL_FLAG -X POST \
            "$DEPLOY_URL" \
            -H "Authorization: Bearer ${{ steps.get_token.outputs.token }}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "HTTP $http_code"
          echo "Response body:"
          cat /tmp/order_resp.json

          order_id=$(jq -r '.id' /tmp/order_resp.json)
          if [ -z "$order_id" ] || [ "$order_id" = "null" ]; then
            echo "Failed to create order" >&2
            exit 1
          fi
          echo "order_id=$order_id" >> $GITHUB_OUTPUT

      - name: Wait for provisioning to complete
        id: wait_order
        env:
          ORDER_ID: ${{ steps.create_order.outputs.order_id }}
        run: |
          BASE="${{ secrets.CB_BASE_URL }}"; BASE="${BASE%/}"
          ORDER_URL="$BASE/api/v3/cmp/orders/${ORDER_ID}/"
          CURL_FLAG='${{ steps.curl_flags.outputs.flag }}'
          if [ -z "$CURL_FLAG" ]; then CURL_FLAG="--insecure"; fi

          # helper: get status with http code
          get_status () {
            http_code=$(curl -s -o /tmp/order.json -w "%{http_code}" $CURL_FLAG \
              "$ORDER_URL" \
              -H "Authorization: Bearer ${{ steps.get_token.outputs.token }}" \
              -H "Accept: application/json")
            status=$(jq -r '.status // empty' /tmp/order.json 2>/dev/null || true)
            echo "$http_code" > /tmp/http_code.txt
            echo "$status" > /tmp/status.txt
          }

          MAX_ATTEMPTS=60   # up to 15 minutes with INTERVAL=15
          INTERVAL=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            get_status
            http_code=$(cat /tmp/http_code.txt)
            status=$(cat /tmp/status.txt)

            echo "Attempt $i: HTTP=$http_code, status=${status:-<empty>}"

            # Re-auth if token expired mid-run
            if [ "$http_code" = "401" ]; then
              echo "Token expired; refreshing…"
              token_resp=$(curl -s $CURL_FLAG -X POST \
                "$BASE/api/v3/cmp/apiToken/" \
                -H "Accept: application/json" -H "Content-Type: application/json" \
                -d "{\"username\":\"${{ secrets.CB_USER }}\",\"password\":\"${{ secrets.CB_USER_PASSWORD }}\"}")
              new_token=$(echo "$token_resp" | jq -r '.token')
              if [ -z "$new_token" ] || [ "$new_token" = "null" ]; then
                echo "Failed to refresh token"; cat /tmp/order.json; exit 1
              fi
              # overwrite the previous output (GitHub doesn't let us mutate prior step outputs, so we just reuse in this step)
              export CB_RUNTIME_TOKEN="$new_token"
              # re-run with fresh token
              http_code=$(curl -s -o /tmp/order.json -w "%{http_code}" $CURL_FLAG \
                "$ORDER_URL" \
                -H "Authorization: Bearer $CB_RUNTIME_TOKEN" \
                -H "Accept: application/json")
              status=$(jq -r '.status // empty' /tmp/order.json 2>/dev/null || true)
              echo "After refresh: HTTP=$http_code, status=${status:-<empty>}"
            fi

            # Normalize and decide
            case "$status" in
              SUCCESS)
                echo "Provisioning completed successfully."
                exit 0
                ;;
              FAILURE|ERROR|ABORTED|CANCELED)
                echo "Provisioning ended with status: $status" >&2
                cat /tmp/order.json
                exit 1
                ;;
              "" )
                # Unexpected/empty status -> print payload to debug, then keep trying a bit
                echo "Warning: empty status; body was:"; cat /tmp/order.json
                ;;
              ACTIVE|PENDING|QUEUED|RUNNING|IN_PROGRESS)
                # keep waiting
                ;;
              * )
                # Unknown status — log and keep waiting a few cycles
                echo "Unknown status '$status'; body:"; cat /tmp/order.json
                ;;
            esac

            sleep $INTERVAL
          done

          echo "Timed out waiting for provisioning to complete." >&2
          exit 1

      - name: Get app URL from Set Resource URL Job
        id: app_url
        env:
          CB_FLAG: ${{ steps.curl_flags.outputs.flag }}
        run: |
          set -euo pipefail
          BASE="${{ secrets.CB_BASE_URL }}"; BASE="${BASE%/}"
          ORDER_ID="${{ steps.create_order.outputs.order_id }}"
          ORDER_URL="$BASE/api/v3/cmp/orders/${ORDER_ID}/"

          TOKEN="${{ steps.get_token.outputs.token }}"

          get_with_token () {
            # args: URL
            local url="$1"
            curl -s ${CB_FLAG} -w "\n%{http_code}" \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Accept: application/json" \
              "$url"
          }

          refresh_token () {
            echo "Refreshing CloudBolt token..."
            resp=$(curl -s ${CB_FLAG} -X POST \
              "$BASE/api/v3/cmp/apiToken/" \
              -H "Accept: application/json" -H "Content-Type: application/json" \
              -d "{\"username\":\"${{ secrets.CB_USER }}\",\"password\":\"${{ secrets.CB_USER_PASSWORD }}\"}")
            newtok=$(echo "$resp" | jq -r '.token')
            if [ -z "$newtok" ] || [ "$newtok" = "null" ]; then
              echo "Failed to refresh token"; echo "$resp"; exit 1
            fi
            TOKEN="$newtok"
          }

          # --- Fetch order JSON (retry once on 401) ---
          read -r body status <<<"$(get_with_token "$ORDER_URL")"
          if [ "$status" = "401" ]; then
            refresh_token
            read -r body status <<<"$(get_with_token "$ORDER_URL")"
          fi
          if [ "$status" != "200" ]; then
            echo "Order GET failed: HTTP $status"; echo "$body"; exit 1
          fi
          echo "$body" > /tmp/order.json
          cat /tmp/order.json

          # Find the "Set Resource URL Job ..." link
          job_href=$(jq -r '._links.jobs[]?[]? | select(.title | startswith("Set Resource URL Job")) | .href' /tmp/order.json)
          if [ -z "${job_href:-}" ] || [ "$job_href" = "null" ]; then
            echo "Could not find 'Set Resource URL Job' in order links"; exit 1
          fi
          job_url="${BASE}${job_href}"
          echo "Resolved job URL: $job_url"

          # --- Fetch the job JSON (retry once on 401) ---
          read -r body status <<<"$(get_with_token "$job_url")"
          if [ "$status" = "401" ]; then
            refresh_token
            read -r body status <<<"$(get_with_token "$job_url")"
          fi
          if [ "$status" != "200" ]; then
            echo "Job GET failed: HTTP $status"; echo "$body"; exit 1
          fi
          echo "$body" > /tmp/job.json
          cat /tmp/job.json

          # Extract the URL
          app_url=$(jq -r '.output[0]' /tmp/job.json)
          if [ -z "${app_url:-}" ] || [ "$app_url" = "null" ]; then
            echo "No URL found in job output"; exit 1
          fi
          app_url=${app_url%/}
          echo "url=$app_url" >> $GITHUB_OUTPUT

      - name: Health check
        run: |
          URL="${{ steps.app_url.outputs.url }}"
          echo "Checking ${URL}/health ..."
          for i in {1..12}; do
            if curl -fs "${URL}/health"; then
              echo "Health check OK"
              exit 0
            fi
            echo "Health not ready yet, retrying ($i/12)..."
            sleep 5
          done
          echo "Health check failed" >&2
          exit 1

      - name: Tear down environment
        if: always()
        run: |
          SID="${{ steps.server_info.outputs.server_id }}"
          if [ -n "$SID" ] && [ "$SID" != "null" ]; then
            echo "Deleting server $SID ..."
            curl -sS ${{ steps.curl_flags.outputs.flag }} -X DELETE \
              "${{ secrets.CB_BASE_URL }}/api/v3/cmp/servers/$SID/" \
              -H "Authorization: Bearer ${{ steps.get_token.outputs.token }}" \
              -H "Accept: application/json"
          else
            echo "No server_id available to delete."
          fi
